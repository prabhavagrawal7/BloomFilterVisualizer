var t=Object.defineProperty,s=(s,i,r)=>((s,i,r)=>i in s?t(s,i,{enumerable:!0,configurable:!0,writable:!0,value:r}):s[i]=r)(s,"symbol"!=typeof i?i+"":i,r);class i{constructor(t,i){s(this,"size"),s(this,"numHashFunctions"),s(this,"bitArray"),s(this,"words"),this.size=t,this.numHashFunctions=i,this.bitArray=new Array(t).fill(!1),this.words=new Set}reset(){this.bitArray=new Array(this.size).fill(!1),this.words.clear()}updateParams(t,s){const i=[...this.words];return this.size=t,this.numHashFunctions=s,this.reset(),i.forEach((t=>this.add(t))),i}hash(t,s){let i=0;for(let r=0;r<t.length;r++)i=(i<<5)-i+t.charCodeAt(r)*s|0;return Math.abs(i)%this.size}getHashPositions(t){const s=[];for(let i=0;i<this.numHashFunctions;i++)s.push(this.hash(t,i+1));return s}add(t){if(this.words.has(t))return!1;return this.getHashPositions(t).forEach((t=>{this.bitArray[t]=!0})),this.words.add(t),!0}remove(t){return!!this.words.has(t)&&(this.words.delete(t),this.reset(),[...this.words].forEach((t=>{this.getHashPositions(t).forEach((t=>{this.bitArray[t]=!0}))})),!0)}mightContain(t){return this.getHashPositions(t).every((t=>this.bitArray[t]))}definitelyContains(t){return this.words.has(t)}getState(){return{bitArray:[...this.bitArray],words:[...this.words],size:this.size,numHashFunctions:this.numHashFunctions}}}class r{constructor(){s(this,"history"),s(this,"maxHistorySize"),this.history=[],this.maxHistorySize=50}addEntry(t,s,i){const r={id:Date.now()+Math.random().toString(36).substring(2,9),timestamp:(new Date).toLocaleTimeString(),type:t,data:s,description:i};return this.history.unshift(r),this.history.length>this.maxHistorySize&&this.history.pop(),r}getHistory(){return[...this.history]}getEntry(t){return this.history.find((s=>s.id===t))}clearHistory(){this.history=[]}}export{i as B,r as H};
